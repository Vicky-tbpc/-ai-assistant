async function processHealthKeyword(config, targetDateStr, isDefinitionQuery) {
    try {
        // --- æƒ…å¢ƒ Aï¼šä½¿ç”¨è€…æ˜¯åœ¨è©¢å•ã€Œå®šç¾©ã€ï¼ˆä»€éº¼æ˜¯... æˆ– å¸¶æœ‰å•è™Ÿï¼‰ ---
        if (isDefinitionQuery) {
            const { data } = await _supabase.from('phrase_library')
                .select('detailed_content')
                .eq('title', config.fallbackTitle)
                .limit(1).maybeSingle();
            
            await appendAiMessage(data?.detailed_content || `ç›®å‰æ²’æœ‰é—œæ–¼ ${config.fallbackTitle} çš„è©³ç´°è³‡æ–™ã€‚`);
            await new Promise(r => setTimeout(r, 800));
            await appendAiMessage(getRandomEndQuestion());
            return; // çµæŸåŸ·è¡Œ
        }

        // --- æƒ…å¢ƒ Bï¼šä½¿ç”¨è€…æ˜¯åœ¨è©¢å•ã€Œæ•¸æ“šã€ï¼ˆå¦‚ï¼šæ˜¨å¤©çš„hbiï¼‰ ---
        const targetDate = new Date(targetDateStr);
        const prevDate = new Date(targetDate);
        prevDate.setDate(prevDate.getDate() - 1);
        const prevDateStr = prevDate.toISOString().split('T')[0];

        const { data: records, error } = await _supabase.from('health_data')
            .select('record_date, raw_json')
            .eq('serial_number', currentSerial)
            .in('record_date', [targetDateStr, prevDateStr]);

        if (error) throw error;

        const targetData = records?.find(r => r.record_date === targetDateStr);
        const prevData = records?.find(r => r.record_date === prevDateStr);

        // åˆ¤æ–·æ˜¯å¦æœ‰ç•¶å¤©æ•¸å€¼
        if (!targetData || targetData.raw_json[config.displayField] === undefined || targetData.raw_json[config.displayField] === null) {
            await appendAiMessage("é€™å¤©æ²’æ•¸æ“šå–”~ ğŸ˜… å¯èƒ½æ˜¯æ²’æœ‰ä¸Šå‚³ï¼Œæˆ–è³‡æ–™å°šæœªåŒæ­¥å®Œæˆã€‚â˜ï¸");
        } else {
            // 1. è™•ç†é¡¯ç¤ºæ•¸å€¼çš„é‚è¼¯
            const rawVal = targetData.raw_json[config.displayField];
            let displayValStr = "";

            // åˆ¤æ–·æ˜¯å¦ç‚ºç¸½ç¡çœ æ™‚é–“ (TST_min)ï¼Œé€²è¡Œå–®ä½æ›ç®—
            if (config.displayField === 'TST_min') {
                const hours = Math.floor(rawVal / 60);
                const mins = rawVal % 60;
                displayValStr = `**${hours}å°æ™‚${mins}åˆ†é˜**`;
            } else {
                displayValStr = `**${rawVal} ${config.unit}**`;
            }

            // çµ„åˆé–‹é ­æ•¸å€¼é¡¯ç¤º (åªå®šç¾©ä¸€æ¬¡)
            const valuePrefix = `ğŸ“Š **${targetDateStr.replace(/-/g,'/')}** çš„${config.fallbackTitle}ç‚ºï¼š${displayValStr}<br><br>`;

            // 2. è™•ç†æ¯”è¼ƒçš„é‚è¼¯ (ä½¿ç”¨ Battery_..._A æ¬„ä½)
            const targetCompareVal = targetData.raw_json[config.compareField];
            const prevCompareVal = prevData ? prevData.raw_json[config.compareField] : null;

            const randomNum = Math.floor(Math.random() * 3) + 1;
            let status = "æœ€ä½³"; 
            if (prevCompareVal !== null) {
                // åŸé‚è¼¯ï¼šä»Šå¤©æ¯”æ˜¨å¤©å°å‰‡ç‚ºæœ€å·®
                if (targetCompareVal < prevCompareVal) status = "æœ€å·®";
            }

            // 3. å¾è³‡æ–™åº«æŠ“å–å°æ‡‰æ–‡å­—
            const targetLogicKey = `${config.prefix}${status}${randomNum}`;
            const { data } = await _supabase.from('phrase_library')
                .select('detailed_content')
                .eq('logic_key', targetLogicKey)
                .limit(1).maybeSingle();
                
            const finalContent = valuePrefix + (data?.detailed_content || `ç›®å‰çš„æ•¸å€¼ç‹€æ…‹ç‚ºï¼š${status}ï¼Œè«‹ç¹¼çºŒä¿æŒå¥åº·çš„ç”Ÿæ´»ç¿’æ…£ï¼`);
            await appendAiMessage(finalContent);
        }

        await new Promise(r => setTimeout(r, 800));
        await appendAiMessage(getRandomEndQuestion());

    } catch (err) {
        console.error("Error:", err);
        await appendAiMessage("æŸ¥è©¢æ™‚ç™¼ç”Ÿä¸€é»å°ç‹€æ³ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚");
    }
}
